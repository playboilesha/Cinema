create tablespace KinoTablepace
datafile 'D:\app\user\prost\KinoTablepace.dat'
size 50 m 
autoextend on next 5 m
maxsize 100m
extent management local;

create temporary tablespace KinoTablepace_temp
tempfile 'D:\app\user\prost\KinoTablepace_temp.dbf'
size 50 m 
autoextend on next 3 m
maxsize 100m
extent management local;


drop user SYSEMKINO;

select TABLESPACE_NAME, STATUS, contents logging from SYS.DBA_TABLESPACES

ALTER SESSION SET "_ORACLE_SCRIPT" = TRUE;

create role RL_UserKino;


grant create session,
create table, 
create view
to RL_UserKino;

alter user XXXCORE1 identified by XXXCORE1 account unlock;
alter user  XXXCORE1 identified by 123456;

select * from dba_role_privs where grantee = 'RL_UserKino' ;
select * from dba_roles; 


ALTER SESSION SET "_ORACLE_SCRIPT" = TRUE;
create profile pf_UserKino limit
password_life_time 180
sessions_per_user 3
failed_login_attempts 7
password_lock_time 1  
password_reuse_time 10
password_grace_time default
connect_time 180
idle_time 30


CREATE USER SysKino
  IDENTIFIED BY 12345
  DEFAULT TABLESPACE CoursTableSpace
  TEMPORARY TABLESPACE CoursTableSpace_temp
  QUOTA 200M on CoursTableSpace;




create user SysemKino identified by 12345 
default tablespace CoursTableSpace quota unlimited on CoursTableSpace
temporary tablespace  CoursTableSpace_temp
profile PF_XXXCORE
account unlock
password expire

grant RL_XXXCORE to SysemKino;

select * from dba_users;




create table users 
(
user_id number generated by default as identity,
user_name varchar2(40) NOT NULL unique,
user_password varchar2(50) NOT NULL,
 CONSTRAINT user_id_pk PRIMARY KEY (user_id)
);

insert into users(user_name,user_password) values('an3all1','12345');

select * from users;
drop table users

create or replace procedure register_user(user_name1 in varchar2,user_password1 in varchar2, user_password2 in varchar2,message out varchar2)
is
input_string      VARCHAR2(4000) := user_password1;
work_string       VARCHAR2(4000);
encrypted_string  VARCHAR2(4000);
num_user number;
BEGIN
if user_password1 = user_password2
then
select count(*) into num_user from users where user_name = user_name1;
if num_user = 0
then
work_string := RPAD
                ( input_string
                , (TRUNC(LENGTH(input_string) / 8) + 1 ) * 8
                , CHR(0)
                );

DBMS_OBFUSCATION_TOOLKIT.DESENCRYPT
           (
             input_string     => work_string
           , key_string       => 'MagicKey'
           , encrypted_string => encrypted_string
           );

insert into users(user_name,user_password) values(user_name1,encrypted_string);
message := 'you are registered';

else
message :='login busy';
DBMS_OUTPUT.PUT_LINE('Такой логин уже есть');
end if;
else
message :='password dont match';
DBMS_OUTPUT.PUT_LINE('Пароли не совподают');
end if;
EXCEPTION
WHEN OTHERS THEN
   raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);
END;

declare
a varchar2(40);
begin
register_user('lesha2','12345','12345',a);
end;
select * from users;

---------------------------
create or replace procedure login_users(user_name1 in varchar2,user_password1 in varchar2,message out varchar2, status out varchar2)
is
input_string VARCHAR2(1000) := user_password1;
work_string VARCHAR2(1000);
encrypted_string  VARCHAR2(1000);
num number;
num2 number;
begin
select count(*) into num from users where user_name = user_name1;
if num > 0
then
work_string := RPAD 
(
   input_string
  , (TRUNC(LENGTH(input_string) / 8) + 1 ) * 8
  , CHR(0)
);
DBMS_OBFUSCATION_TOOLKIT.DESENCRYPT
           (
             input_string     => work_string
           , key_string       => 'MagicKey'
           , encrypted_string => encrypted_string
           );

select count(*) into num2 from users where user_password = encrypted_string;
if num2 > 0
then
message := 'login correct';
status := 'true';
DBMS_OUTPUT.PUT_LINE('Логин и пароль верен');
DBMS_OUTPUT.PUT_LINE('Логин '||user_name1|| ' '||'пароль '||user_password1);
else 
message := 'password incorrect';
status := 'false';
DBMS_OUTPUT.PUT_LINE('пароль не верен');
end if;
else 
message := 'login incorrect';
status := 'false';
DBMS_OUTPUT.PUT_LINE('логин не верен');
end if;
end;


declare
a varchar2(40);
b varchar2(40);
begin
LOGIN_USERS('an3all','12345',a,b);
end;

--------------------
DECLARE
input_string VARCHAR2(4000) := 'Morgen, morgen, nur nicht heute';

work_string VARCHAR2(4000);

encrypted_string VARCHAR2(4000);

decrypted_string VARCHAR2(4000);

BEGIN
DBMS_OUTPUT.PUT_LINE(input_string);

work_string := RPAD
(
   input_string
  , (TRUNC(LENGTH(input_string) / 8) + 1 ) * 8
  , CHR(0)
);

DBMS_OBFUSCATION_TOOLKIT.DESENCRYPT
(
   input_string => work_string
  ,key_string => 'MagicKey'
  ,encrypted_string => encrypted_string
);
DBMS_OUTPUT.PUT_LINE(encrypted_string);

DBMS_OBFUSCATION_TOOLKIT.DESDECRYPT
(
   input_string => encrypted_string
  ,key_string => 'MagicKey'
  ,decrypted_string => work_string
);

decrypted_string := RTRIM(work_string, CHR(0));

DBMS_OUTPUT.PUT_LINE(decrypted_string);
END;


-------------------TABLE FILMS
create table Films
(
Film_name varchar2(1000) not null ,
Director varchar2(1000) not null,
Genre_name varchar2(20) not null  CHECK (Genre_name IN ('action', 'drama', 'melodrama', 'fantasy', 'family', 'documentary', 'western', 'adventure', 'comedy')),
Duration_film number check(Duration_film <1000),
Year_film DATE,
Film_opis varchar2(2000),
CONSTRAINT Film_name_pk PRIMARY KEY (Film_name)

);
drop table films
ALTER TABLE Films
ADD CONSTRAINT Genre_name_constr
  CHECK (Genre_name IN ('action', 'drama', 'melodrama', 'fantasy', 'family', 'documentary', 'western', 'adventure', 'comedy'));

select * from films
-----------------TABLE GENRE

create table Genre(
Genre_name varchar2(20) not null   CHECK (Genre_name IN ('action', 'drama', 'melodrama', 'fantasy', 'family', 'documentary', 'western', 'adventure', 'comedy')),
Film_name varchar2(1000) not null,
CONSTRAINT Genre_name_pk PRIMARY KEY (Genre_name),
 CONSTRAINT fk_Film_name
    FOREIGN KEY (Film_name)
    REFERENCES Films(Film_name)
);
ALTER TABLE Genre
ADD CONSTRAINT Genre_name_const
  CHECK (Genre_name IN ('action', 'drama', 'melodrama', 'fantasy', 'family', 'documentary', 'western', 'adventure', 'comedy'));

DROP CONSTRAINT Genre_name_pk;
--------------------table director
create table Director(
Director_name varchar2(1000) not null ,
Film_name varchar2(1000) not null,
Director_opis varchar2(1000) not null,
CONSTRAINT Director_name_pk PRIMARY KEY (Director_name),
 CONSTRAINT fk_Film_name_d
    FOREIGN KEY (Film_name)
    REFERENCES Films(Film_name)
    
);

insert into director(Director_name,Film_name,Director_opis)
values('Terrence Malick','The Tree of Life','Terrence Frederick Malick (born November 30, 1943)[1] is an American filmmaker. His films include Days of Heaven (1978), The Thin Red Line (1998), for which he received Academy Award nominations for Best Director and Best Adapted Screenplay, The New World (2005) and The Tree of Life (2011), the latter of which garnered him another Best Director Oscar nomination and the Palme dOr at the 64th Cannes Film Festival');
insert into director(Director_name,Film_name,Director_opis) 
values('Tim Miller','Deadpool','Timothy Miller (born October 10, 1964) is an American filmmaker. anthology series Love, Death & Robots, for which he has received several Primetime Emmy nominations and awards.');
drop table Genre
select * from director
delete films where director = 'Terrence Malick';

insert into Films(Film_name,Director,Genre_name,Duration_film,Year_film,Film_opis) values('The Tree of Life','Terrence Malick','drama',139,to_date('2011','YYYY'),'The story of a family in Waco, Texas in 1956. The eldest son witnesses the loss of innocence and struggles with his parents conflicting teachings.');
insert into Films(Film_name,Director,Genre_name,Duration_film,Year_film,Film_opis)
values('Deadpool','Tim Miller','action',108,to_date('2016-12-01','YYYY-MM-DD'),'A wisecracking mercenary gets experimented on and becomes immortal but ugly, and sets out to track down the man who ruined his looks.');


delete films where Director = 'Tim Miller';
delete from genre where Genre_na = 'Ли Вон-тхэ'
select * from Films join Genre on Films.Film_name = Genre.Film_name;
select * from genre
select * from director;

---trigger insert genre after insert films
CREATE OR REPLACE TRIGGER Insert_genre
AFTER INSERT ON Films
FOR EACH ROW
BEGIN
    INSERT INTO Genre
    (Genre_name, Film_name)
    VALUES (:new.Genre_name, :new.Film_name);
END Insert_genre;



---trigger delete genre ofter delete films
CREATE OR REPLACE TRIGGER delete_genre
AFTER delete ON Films
FOR EACH ROW
BEGIN
DELETE FROM Genre
WHERE film_name = :old.Film_name and Genre_name =:old.Genre_name;
END delete_genre;


select * from sessions;
----trigger insert cinema insert session_id cinema name
CREATE OR REPLACE TRIGGER insert_session
AFTER insert ON sessions
declare
max_id number;
BEGIN
select max(session_id)into max_id from sessions;
insert into sessions(session_id,cinema_name) values(max_id+1,'an3all');
END insert_session;

drop trigger insert_session;


------------------TABLE SESSion

create table sessions(
session_id number,
cinema_name varchar2(50) not null,
hall_id number check(hall_id = 1 or hall_id = 2 or hall_id = 3) not null,
Film_name varchar2(1000) not null,
session_start date not null,
session_time  number not null,
session_price varchar2(20) check (session_price like '%$') not null,
session_status varchar2(12) not null check(session_status = 'not started' or session_status = 'started'),
CONSTRAINT session_id_pk PRIMARY KEY (session_id),
 CONSTRAINT cinema_name_fk
    FOREIGN KEY (cinema_name)
    REFERENCES cinema(cinema_name),
    CONSTRAINT hall_id_fk
    FOREIGN KEY (hall_id)
    REFERENCES halls(hall_id),
      CONSTRAINT Film_name_fk
    FOREIGN KEY (Film_name)
    REFERENCES Films(Film_name)
);
drop table sessions;
select * from sessions;

insert into sessions(session_id,cinema_name,hall_id,Film_name,session_start,session_time,session_price,session_status)
        values(1,'an3all',1,'The Tree of Life',to_date('2023-4-29','YYYY-MM-DD'),139,'5$','not started');
        insert into sessions(session_id,cinema_name,hall_id,Film_name,session_start,session_time,session_price,session_status)
        values(2,'an3all',1,'Deadpool',to_date('2023-5-29','YYYY-MM-DD'),108,'6$','not started');
        delete from sessions where cinema_name = 'an3all';
        
        
        
        
------------------procedure info session
create or replace procedure Info_Sessions_start(strings out sys_refcursor,status in varchar2)
is
begin
open strings for
select * from SYSTEM.sessions where session_status = status;
end;

drop procedure Info_Sessions_start
  

declare 
cur sys_refcursor;
fetc sessions%rowtype; --define the record
begin
    pack_user.Info_Sessions_start(cur,'not started');  
 LOOP
  FETCH cur INTO fetc;
  EXIT WHEN cur%NOTFOUND;
  dbms_output.put_line('номер сеанса: '||fetc.session_id||' кинотеатр '||fetc.cinema_name||' зал: '||fetc.hall_id||' фильм '||fetc.film_name||' начало: '||fetc.session_start||' время: '||fetc.session_time||' цена: '||fetc.session_price||' статус: '||fetc.session_status);
END LOOP;
end;
------------------TABEl HALL

create table halls(
hall_id number check(hall_id = 1 or hall_id = 2 or hall_id = 3),
hall_name varchar2(20) check(hall_name = 'blue' or hall_name = 'red' or hall_name = 'black' ) not null,
count_place number not null,
CONSTRAINT hall_id_pk PRIMARY KEY (hall_id)
);
drop table halls;
select * from halls;
insert into halls(hall_id,hall_name,count_place) values(1,'blue',150);
insert into halls(hall_id,hall_name,count_place) values(2,'red',100);
insert into halls(hall_id,hall_name,count_place) values(3,'black',50);

  ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD'
----------Cinema

Create table cinema(
cinema_name varchar2(50),
cinema_telephone  varchar2(13) check(cinema_telephone like '+%') not null,
cinema_locate varchar2(50) not null,
CONSTRAINT cinema_name_pk PRIMARY KEY (cinema_name)
);
drop table cinema;
insert into cinema(cinema_name,cinema_telephone,cinema_locate) values('an3all','+375293637526','Minsk, boga 2');
select * from cinema;

----------TABLE BOKKING
create table BOOKING(
booking_id number generated always as identity,
user_name varchar2(40) NOT NULL,
session_id number not null,
place_number number check(place_number <151),
CONSTRAINT booking_id_pk PRIMARY KEY (booking_id),
  CONSTRAINT session_id_fk
    FOREIGN KEY (session_id)
    REFERENCES sessions(session_id),
     CONSTRAINT user_name_fk
    FOREIGN KEY (user_name)
    REFERENCES users(user_name)
);
drop table booking;
drop table 
select * from check_user;

delete from check_user where user_name = 'an3all';

------------------------------------------------------view с местами
-----------------------------------------------------проедура проверки есть ли сеанс
create or replace procedure Check_session(session_id1 in number,message out varchar2,status out varchar2)
is 
num number;
begin
select count(*) into num from sessions where session_id = session_id1;
if num = 1
then
message:='good';
status := 'true';
else
message:='no search session';
status := 'false';
end if;
end;


declare
session_id1 number;
message  varchar2(20);
status  varchar2(20);
begin
Check_session(3,message,status);
dbms_output.put_line(message);
dbms_output.put_line(status);
end;
------------------------------------------------------Просмотр забронированных мест и свободных мест

create or replace procedure search_place(session_id1 in number,places out sys_refcursor,count_place1 out halls.count_place%type,filmname out sessions.film_name%type)
is
cursor curs is select place_number from BOOKING where session_id = session_id1;
i number := 1;
begin
select halls.count_place, sessions.film_name into count_place1,filmname from sessions join halls on sessions.hall_id = halls.hall_id  where sessions.session_id = session_id1;
dbms_output.put_line('Количество мест: ' || count_place1);
dbms_output.put_line('Фильм: ' || filmname);
dbms_output.put_line('Номера занятых мест:');

for fcurs in curs
loop
dbms_output.put_line(fcurs.place_number);
end loop;
open places for select place_number from BOOKING where session_id = session_id1;
end;


declare 
cur sys_refcursor;
count_place1 halls.count_place%type;
num  booking.place_number%type;
filmname  sessions.film_name%type;
begin
search_place(1,cur,count_place1,filmname);
---- LOOP
--- FETCH cur INTO num;
---  EXIT WHEN cur%NOTFOUND;
---  dbms_output.put_line(num);
--- END LOOP;
end;
select * from halls;
------------------------------------------------------Бронирование билета на сеанс
create or replace procedure BOKKING_USER(user_name1 varchar2,session_id1 number,place_number1 number,message out varchar2)
is
user_num number;
session_num number;
session_status varchar2(12);
place_count number;
check_count_place number;
begin
select a.count_place into check_count_place from halls a join sessions b on a.hall_id = b.hall_id where b.session_id = session_id1 and  ROWNUM = 1;
select count(*) into user_num from users where user_name = user_name1;
select count(*) into session_num  from sessions where session_id = session_id1;
select session_status into session_status  from sessions where session_id = session_id1;
select count(*) into place_count  from BOOKING where session_id = session_id1 and place_number = place_number1;
if place_number1 < check_count_place+1
then
 dbms_output.put_line('Место существует');
if user_num > 0
then
  dbms_output.put_line('хорошо');
  if session_num > 0
  then
      dbms_output.put_line('Сеанс есть');
     if session_status = 'not started'
     then
        dbms_output.put_line('сеанс не начался');
        if place_count = 0
        then
          dbms_output.put_line('место свободно и забранированно');
          message := 'you reserved place';
          insert into BOOKING(user_name,session_id,place_number) values(user_name1,session_id1,place_number1);
        else
          dbms_output.put_line('место занято');
           message := 'place occupied';
        end if;
    else
      dbms_output.put_line('сеанс начался');
      message := 'session start';
      end if;
  else 
    dbms_output.put_line('такого сеанса нет');
    message := 'no search session';
    end if;
else
dbms_output.put_line('Такого логина нет');
message := 'loggin incorrect';
end if;
else
dbms_output.put_line('Места не существует');
message := 'no search place';
end if;
exception
when others then
dbms_output.put_line(sqlerrm);
end;

declare
message varchar2(40);
begin
bokking_user('an3all',3,2,message);
end;
commit;
select * from sessions;


-----------просмотр забронированные мест определенного пользователя

select c.session_id,c.film_name,c.session_start,c.session_price,c.session_time,b.place_number from users a join booking b on a.user_name = b.user_name join sessions c on b.session_id = c.session_id where a.user_name = 'an3all' and c.session_status = 'not started';
create or replace procedure check_booking_user(user_name1 in varchar2,cur out sys_refcursor)
is cursor curs is select c.session_id,c.film_name,c.session_start,c.session_price,b.place_number from users a join booking b on a.user_name = b.user_name join sessions c on b.session_id = c.session_id where a.user_name = user_name1 and c.session_status = 'not started';
begin
for fcurs in curs
loop
dbms_output.put_line('ID: '||fcurs.session_id||' Название фильма: '||fcurs.film_name||' Начало сеанса: '||fcurs.session_start||' Цена: '||fcurs.session_price||' Номер места: '||fcurs.place_number);
end loop;
open cur for
select c.session_id,c.film_name,c.session_start,c.session_price,b.place_number from users a join booking b on a.user_name = b.user_name join sessions c on b.session_id = c.session_id where a.user_name = user_name1 and c.session_status = 'not started';
exception
when others
then 
  raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);  
end;
commit

declare
cur sys_refcursor;
begin
check_booking_user('an3all',cur);
end;

-----------Pocedure watch info for films
create or replace procedure Info_films(strings out sys_refcursor)
is 
cursor curs is select * from films;
begin
for fcurs in curs
loop
dbms_output.put_line('Имя: '||fcurs.Film_name||' Режисер: '||fcurs.Director||' Жанр: '||fcurs.Genre_name||' Продолжительность: '||fcurs.Duration_film||' Год: '||fcurs.Year_film||' Описание: '||fcurs.Film_opis);
end loop;
open strings for
select * from Films;
end;

DECLARE
   cur sys_refcursor;
   -- Film_name varchar2(1000);
   -- Director varchar2(1000);
   -- Genre_name varchar2(20);
   -- Duration_film number;
   -- Year_film DATE;
   -- Film_opis varchar2(2000);
BEGIN
    Info_films(cur);  
   -- LOOP
     --  EXIT WHEN cur%notfound;
     -- FETCH cur INTO Film_name, Director,Genre_name,Duration_film,Year_film,Film_opis;
     --  dbms_output.put_line('Имя: '||Film_name||' Режисер: '||Director||' Жанр: '||Genre_name||' Продолжительность: '||Duration_film||' Год: '||Year_film||' Описание: '||Film_opis);
   -- END LOOP;     
END;


---------------------Процедура информация о жанрах
create or replace 
procedure Info_Genre(Genre_name1 in varchar, strings out sys_refcursor)
is 
cursor curs is select * from genre where Genre_name = Genre_name1;
begin
for fcurs in curs
loop
dbms_output.put_line('Имя: '||fcurs.Film_name||' Жанр: '||fcurs.Genre_name);
end loop;
open strings for
select * from Genre where Genre_name = Genre_name1;
end;

DECLARE
    cur sys_refcursor;
    --Film_name varchar2(1000);
    --Genre_name varchar2(20);
BEGIN
    Info_genre('drama', cur);  
     
      --FETCH cur INTO Genre_name,Film_name;
       --dbms_output.put_line('Имя: '||Film_name||' Жанр: '||Genre_name);       
END;


---------------------Процедура информация о режисеррах
create or replace 
procedure Info_Direcor(Film_name1 in varchar2, strings out sys_refcursor,message out varchar2)
is 
cursor curs is select * from director where contains(Film_name, '%'||Film_name1||'%') > 0;
num number;
begin
select count(*) into num from director where contains(Film_name, '%'||Film_name1||'%') > 0;
message := 'no search';
if num = 0
then
message :='no search';
dbms_output.put_line(message);
else
for fcurs in curs
loop
dbms_output.put_line('Имя: '||fcurs.Director_name||' Название фильма: '||fcurs.Film_name||' Описание директора: '||fcurs.Director_opis);
end loop;
open strings for
select * from director where contains(Film_name, '%'||Film_name1||'%') > 0;
message :='good';
end if;
exception
when others
then 
  raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);  
end;

DECLARE
    cur sys_refcursor;
    --Film_name varchar2(1000);
    --Director_name varchar2(20);
    --Director_opis varchar2(1000);
    message varchar2(20);
BEGIN

Info_Direcor('ve',cur,message);
-- if cur%isopen then
--LOOP
--FETCH cur INTO Director_name,Film_name,Director_opis;
--EXIT WHEN cur%notfound;
--dbms_output.put_line('Имя: '||Director_name||' Название фильма: '||Film_name||' Описание директора: '||Director_opis||' '|| message);
--END LOOP;
--close cur;
--else
--.put_line(message);
--end if;
END;

select * from director;
begin
    ctx_ddl.create_preference('my_wordlist1', 'BASIC_WORDLIST');
    ctx_ddl.create_preference('my_lexer1', 'AUTO_LEXER');
    ctx_ddl.set_attribute('my_lexer1', 'INDEX_STEMS','YES');
end;
create index film_namex on Director (Film_name) indextype is ctxsys.context parameters ('LEXER my_lexer1 WORDLIST my_wordlist1');
ALTER INDEX film_namex REBUILD;
select * from director where contains(Film_name, 'Venom%') > 0;

------------процедура поиска информации о фильме по названию

GRANT EXECUTE ON CTX_DDL TO System;
begin
    ctx_ddl.create_preference('my_wordlist2', 'BASIC_WORDLIST');
    ctx_ddl.create_preference('my_lexer2', 'AUTO_LEXER');
    ctx_ddl.set_attribute('my_lexer2', 'INDEX_STEMS','YES');
end;
create index film_name_film on films (Film_name) indextype is ctxsys.context parameters ('LEXER my_lexer2 WORDLIST my_wordlist2');
select * from films;
select * from films where contains(Film_name, 've%') > 0;

create or replace
procedure search_film_for_name(Film_name1 in varchar2,strings out sys_refcursor,message out varchar2)
is 
cursor curs is select * from films where contains(Film_name, '%'||Film_name1||'%') > 0;
num number;
index_name varchar2(20) := 'film_name_film';
begin
execute immediate 'alter index ' || index_name || ' rebuild';
select count(*) into num from films where contains(Film_name, '%'||Film_name1||'%') > 0;
message := 'no search';
if num = 0
then
message :='no search';
dbms_output.put_line(message);
else
for fcurs in curs
loop
dbms_output.put_line('Название: '||fcurs.Film_name||' Режисер: '||fcurs.Director||' Жанр: '||fcurs.Genre_name||' Продолжительность: '||fcurs.Duration_film||' Год: '||fcurs.Year_film||' Описание: '||fcurs.Film_opis);
end loop;
open strings for
select * from films where contains(Film_name, '%'||Film_name1||'%') > 0;
message :='good';
end if;
exception
when others
then 
  raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);  
end;


declare
message varchar2(20);
cur sys_refcursor;
begin
search_film_for_name('Ve',cur,message);
end;
---предстовление о кинотеатрах

CREATE OR REPLACE VIEW cinema_v
AS SELECT *
FROM cinema;

select * from cinema_v;

---предстовление о залах

CREATE OR REPLACE VIEW halls_v
AS SELECT *
FROM halls;

select * from halls_v;
----процедура информация о кинотетрах
create or replace 
procedure info_cinema_v(strings out sys_refcursor)
is cursor curs is select * from cinema_v;
begin
for fcurs in curs
loop
dbms_output.put_line('Название: '||fcurs.cinema_name||' Номер телефона: '||fcurs.cinema_telephone||' где находится: '||fcurs.cinema_locate);
end loop;
open strings for
 select * from cinema_v;
exception
when others
then 
  raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);  
end;

declare 
strings sys_refcursor;
begin
info_cinema_v(strings);
end;

----процедура информация о залах
create or replace 
procedure info_halls_v(strings out sys_refcursor)
is cursor curs is select * from halls_v;
begin
for fcurs in curs
loop
dbms_output.put_line('Id: '||fcurs.hall_id||' Название: '||fcurs.hall_name||' количество мест: '||fcurs.count_place);
end loop;
open strings for
 select * from halls_v;
exception
when others
then 
  raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);  
end;

declare 
strings sys_refcursor;
begin
info_halls_v(strings);
end;
------------------root

-------table check_user

create table check_user(
check_user_id number,
user_name varchar2(40) NOT NULL,
session_id number not null,
place_number number check(place_number <151),
status varchar(20) default 'none' check(status = 'none' or status = 'yes' or status = 'no'),
CONSTRAINT check_user_id_pk PRIMARY KEY (check_user_id),
  CONSTRAINT session_id_chk_fk
    FOREIGN KEY (session_id)
    REFERENCES  sessions(session_id),
     CONSTRAINT user_name_chk_fk
    FOREIGN KEY (user_name)
    REFERENCES  users(user_name)
);
select * from booking;
commit;
drop table check_user;

select * from check_User;


----------материализованное представление проверкаи польвателей
CREATE OR REPLACE VIEW check_user_v
AS SELECT *
FROM check_user
select * from check_user_v;
-----------trigger Insert_check_user
CREATE OR REPLACE TRIGGER Insert_check_user
AFTER INSERT ON Booking
FOR EACH ROW
declare
id_check_user1 number;
first_id number;
BEGIN
select max(check_user_id) into id_check_user1 from check_user;
select count(*) into first_id  from check_user;
if first_id = 0
then
    INSERT INTO check_user
    (check_user_id, user_name, session_id,place_number)
    VALUES (1,:new.user_name, :new.session_id, :new.place_number);
else
    INSERT INTO check_user
    (check_user_id, user_name, session_id,place_number)
    VALUES (id_check_user1+1,:new.user_name, :new.session_id, :new.place_number);
end if;
END Insert_check_user;

--------info checkuser
create or replace procedure info_check_v_user(session_id1 in number,cur out sys_refcursor,message out varchar2)
is
cursor curs is select * from check_user_v where session_id = session_id1;
i number;
g number;
begin
select count(*) into i from sessions where session_id = session_id1;
select count(*) into g from check_user_v  where session_id = session_id1;
if i > 0
then
if g = 0
then
message :='no search people';
dbms_output.put_line(message);
else
for fcurs in curs
loop
dbms_output.put_line('ID: '||fcurs.check_user_id||' User_name: '||fcurs.user_name||' session_id: '||fcurs.session_id||' num_pace: '||fcurs.place_number||' status: ' ||fcurs.status);
end loop;
message :='good';
dbms_output.put_line(message);
open cur for select * from check_user_v where session_id = session_id1;
end if;
else
message :='no search session';
dbms_output.put_line(message);
end if;
EXCEPTION
WHEN OTHERS THEN
message :='error';
dbms_output.put_line(message||' '||sqlerrm);
end;

commit
declare 
cur sys_refcursor;
message varchar(30);
begin
info_check_v_user(2,cur,message);
end;

select * from booking;
-------procedure update_hceckUser
create or replace procedure update_check_user(check_user_id1 in number,status1 in varchar2,message out varchar2)
is
begin
update check_user set status = status1 where check_user_id = check_user_id1;
message :='updated';
dbms_output.put_line(message);
EXCEPTION
WHEN OTHERS THEN
message :='error';
dbms_output.put_line(message||' '||sqlerrm);
end update_check_user;

commit;
declare 
message varchar(40);
begin
update_check_user(1,'none',message);
end;

drop table check_user
select * from check_user_v;
select * from booking
insert into check_user(user_name,session_id,place_number) values('an3all',1,3);


---------процедура добавления иформации о режисерах
select * from director;
select * from films;
create or replace
procedure insert_director(director_name1 in director.director_name%type,film_name1 in director.film_name%type,director_opis1 in director.director_opis%type,message out varchar2)
is 
num_film number;
index_name varchar2(40) := 'film_namex';
begin
select count(*) into num_film from films where film_name = film_name1;
if num_film = 1
then
insert into director(director_name,film_name,director_opis) values(director_name1,film_name1,director_opis1);
message := 'data add';
dbms_output.put_line(message);
execute immediate 'alter index ' || index_name || ' rebuild';
else
message := 'no search film';
dbms_output.put_line(message);
end if;
EXCEPTION
WHEN OTHERS THEN
message :='error';
dbms_output.put_line(message||' '||sqlerrm);
end;

declare 
message varchar2(40);
begin
insert_director('Ruben Fleischer','Venom','Ruben Samuel Fleischer (born October 31, 1974) is an American film director, film producer, television producer, music video director, and commercial director who lives in Montclair, New Jersey. He is best known as the director of Zombieland (2009), his first feature film, and its sequel Zombieland: Double Tap (2019)',message);
end;


----------прпоцедура удаления режисера
create or replace procedure delete_director(director_name1 in director.director_name%type,message out varchar2)
is
num_director number;
begin
select count(*)into num_director from director where director_name = 'Terrence Malick';
if num_director > 0
then
delete director where director_name = director_name1;
message := 'data delete';
dbms_output.put_line(message);
else
message := 'no search film';
dbms_output.put_line(message);
end if;
EXCEPTION
WHEN OTHERS THEN
message :='error';
dbms_output.put_line(message||' '||sqlerrm);
end;

declare 
message varchar2(40);
begin
delete_director('Ruben Fleischer',message);
end;
commit
------------------процеду добавления фильиа
select * from films;
select * from genre;
create or replace
procedure insert_film(film_name1 in varchar2, director1 in varchar2, genre_name1 in varchar2,duration_film1 in number,year_film1 in varchar2,film_opis1 in varchar2,message out varchar2)
is
year_fi date := to_date(year_film1,'YYYY');
len number;
namee films.film_name%type;
begin
SELECT INITCAP(film_name1) into namee  FROM DUAL;
SELECT LENGTH(year_film1) into len FROM DUAl;
if len = 4
then
insert into films(film_name,director,genre_name,duration_film,year_film,film_opis) values(namee,director1,genre_name1,duration_film1,year_fi,film_opis1);
message := 'data add';
dbms_output.put_line(message);
else
message := 'date bad';
end if;
EXCEPTION
WHEN OTHERS THEN
message :='error';
dbms_output.put_line(message||' '||sqlerrm);
end;

insert into Films(Film_name,Director,Genre_name,Duration_film,Year_film,Film_opis)
values('Deadpool','Tim Miller','action',108,to_date('2016-12-01','YYYY-MM-DD'),'A wisecracking mercenary gets experimented on and becomes immortal but ugly, and sets out to track down the man who ruined his looks.');


declare 
message varchar2(40);
begin
insert_film('venom1','Ruben Fleischer1','action',112,'2018','A failed reporter is bonded to an alien entity, one of many symbiotes who have invaded Earth. But the being takes a liking to Earth and decides to protect it',message);
end;

commit

--------procedure add sesions
select * from sessions
create or replace procedure insert_sessions(
hall_id1 in sessions.hall_id%type
,film_name1 in sessions.film_name%type
,session_start1 in varchar2
,session_price1 in sessions.session_price%type
,session_status1 in sessions.session_status%type
,message out varchar2)
is
max_id number;
duration1 number;
price varchar2(20);
num_film number;
datee date := to_date(session_start1,'DD.MM.YYYY');
begin
price := session_price1 || '$';
select count(*) into num_film from films where film_name = film_name1 and rownum = 1;
if num_film > 0
then
select duration_film into duration1 from films where film_name = film_name1;
select max(session_id)into max_id from sessions;
insert into sessions(session_id,cinema_name,hall_id,film_name,session_start,session_time,session_price,session_status) values(max_id+1,'an3all',hall_id1,film_name1,datee,duration1,price,session_status1);
message := 'data insert';
dbms_output.put_line(message);
else
message := 'no search film';
dbms_output.put_line(message);
end if;
EXCEPTION
WHEN OTHERS THEN
message :='error';
dbms_output.put_line(message||' '||sqlerrm);
end;
commit
declare 
message varchar2(40);
begin
insert_sessions(1,'VezdfCm','23.09.2023','6','not started',message);
end;

-----------------------процедура удаления сеанса
create or replace procedure delete_sessions(session_id1 in number,message out varchar2)
is
num_session number;
begin
select count(*) into num_session from sessions where session_id=session_id1;
if num_session = 1
then
delete sessions where session_id = session_id1;
message := 'data delete';
dbms_output.put_line(message);
else
message := 'no search session';
dbms_output.put_line(message);
end if;
EXCEPTION
WHEN OTHERS THEN
message :='error';
dbms_output.put_line(message||' '||sqlerrm);
end;

declare 
message varchar2(40);
begin
delete_sessions(4,message);
end;

-------------------------процедура изменения сеан
create or replace procedure update_sessions(session_id1 in number, session_status1 in sessions.session_status%type,message out varchar2)
is
num_session number;
begin
select count(*) into num_session from sessions where session_id=session_id1;
if num_session = 1
then
update sessions set session_status = session_status1 where session_id = session_id1;
message := 'data update';
dbms_output.put_line(message || 'изменено на: '||session_status1);
else
message := 'no search session';
dbms_output.put_line(message);
end if;
EXCEPTION
WHEN OTHERS THEN
message :='error';
dbms_output.put_line(message||' '||sqlerrm);
end;

declare 
message varchar(40);
begin
update_sessions(1,'not started',message);
end;
-------------------------процедура удаление фильма
create or replace procedure delete_film(film_name1 in films.film_name%type,message out varchar2)
is
num number;
num_session number;
begin
select count(*) into num_session from sessions where film_name = film_name1;
select count(*) into num from films where film_name = film_name1;
if num = 1
then
if num_session = 0
then
DELETE FROM films WHERE film_name = film_name1;
message := 'data delete';
dbms_output.put_line(message);
else
message := 'film use session';
dbms_output.put_line(message);
end if;
else
message := 'no search film';
dbms_output.put_line(message);
end if;
EXCEPTION
WHEN OTHERS THEN
message :='error';
dbms_output.put_line(message||' '||sqlerrm);
end;
commit


declare 
message varchar2(40);
begin
delete_film('Venom',message);
end;

----процедура просверка сеанса
create or replace procedure session_status
is cursor curs is select session_start from sessions;
sysdates date;
dates date;
begin
for fcurs in curs
loop
if sysdate >= fcurs.session_start
then
update sessions set session_status = 'started' where session_start = fcurs.session_start;
end if;
end loop;
EXCEPTION
WHEN OTHERS THEN
dbms_output.put_line(sqlerrm);
end;
select * from sessions;

begin
session_status();
end;
------full text search

GRANT EXECUTE ON CTX_DDL TO System;
begin
    ctx_ddl.create_preference('my_wordlist', 'BASIC_WORDLIST'); --Используйте параметр списка слов, чтобы включить такие параметры запроса, как выделение корней и нечеткое сопоставление для вашего языка. Вы также можете использовать параметр «Список слов», чтобы включить индексирование подстрок и префиксов, что повышает производительность для запросов с подстановочными знаками с и . CONTAINSCATSEARCH
      ctx_ddl.create_preference('my_lexer', 'AUTO_LEXER');
    ctx_ddl.set_attribute('my_lexer', 'INDEX_STEMS','YES'); --Укажите для индексации информацию о теме на английском или французском языках. Это делает запросы более точными. Атрибуты и не могут быть одновременно . Значение по умолчанию
end;
create index film_idx on films (Film_opis) indextype is ctxsys.context parameters ('LEXER my_lexer WORDLIST my_wordlist');
drop index film_idx;
  select * from films;
  select * from films where contains(Film_opis, 'monster') > 0;
  
  
  
  select * from films where contains(Film_opis, 'falls {and} love') > 0;
  
    select * from films where contains(Film_opis, '!moon') > 0;
  
  
  
select * from films where contains(Film_opis, 'monster ~ green') > 0;
select * from films where contains(Film_opis, 'accident') > 0;
select * from films where contains(Film_opis, 'near((accident,raging), 8)') > 0;
select * from films where contains(Film_opis, 'near((accident,raging), 5)') > 0;
select * from films where contains(Film_opis, 'must;to') > 0; --слова расположенные вместе
select * from films where contains(Film_opis, 'fgfg| dgsd') > 0;
---сравнение лайк и full text search
select * from films where Film_opis like ('%monster%') ;
explain plan for select * from films where Film_opis like ('%monster%') ;
select plan_table_output from table(dbms_xplan.display());

explain plan for select * from films where contains(Film_opis, 'monster') > 0;
select plan_table_output from table(dbms_xplan.display());


--------------запись данных из текстового файла и в текстовый

spool 'D:\6 сем\kurs bd\filmselect.csv'
SELECT /*csv*/ * FROM films;
spool off




GRANT READ, WRITE ON DIRECTORY infilee TO system
CREATE or replace DIRECTORY infilee AS 'D:\6 сем\kurs bd';

-----Процедура записи в файл
CREATE OR REPLACE PROCEDURE INFILE AS
  CURSOR c_data IS
    SELECT *
    FROM   films;
    
  v_file  UTL_FILE.FILE_TYPE;
BEGIN
  v_file := UTL_FILE.FOPEN(location     => 'INFILEE',
                           filename     => 'text.txt',
                           open_mode    => 'w',
                           max_linesize => 32767);
  FOR cur_rec IN c_data LOOP
    UTL_FILE.PUT_LINE(v_file,
                      cur_rec.film_name    || ',' ||
                      cur_rec.director    || ',' ||
                      cur_rec.genre_name     || ',' ||
                      cur_rec.duration_film      || ',' ||
                      cur_rec.year_film || ',' ||
                      cur_rec.film_opis );
  END LOOP;
  UTL_FILE.FCLOSE(v_file);
  
EXCEPTION
  WHEN OTHERS THEN
    UTL_FILE.FCLOSE(v_file);
    RAISE;
END;

begin
INFILE();
end;

select * from films;
-----импорт в файл хмл
CREATE or replace DIRECTORY infilexml AS 'D:\6 сем\kurs bd\xml';

CREATE OR REPLACE PROCEDURE INFILE_XML AS
MYCLOB CLOB;
v_file  UTL_FILE.FILE_TYPE;
BEGIN
  select dbms_xmlgen.getxml('select * from films') into MYCLOB from DUAL;
    v_file := UTL_FILE.FOPEN(location     => 'INFILEXML',
                             filename     => 'input.xml',
                             open_mode    => 'w',
                             max_linesize => 32767);
      UTL_FILE.PUT(v_file,MYCLOB);
  
    UTL_FILE.FCLOSE(v_file);
  
EXCEPTION
  WHEN OTHERS THEN
    UTL_FILE.FCLOSE(v_file);
    RAISE;
END;

begin
INFILE_XML();
end;


----их хмл в бд

create or replace procedure exportXmlToFIlms
as
begin
insert into films(film_name,director,genre_name,duration_film,year_film,film_opis)
select * from xmltable('/ROWSET/ROW' 
  passing xmltype(BFILENAME('INFILEXML','output.xml'),
  nls_charset_id('char_cs'))
  columns film_name varchar2(1000) PATH 'FILM_NAME',
          director varchar2(1000) PATH 'DIRECTOR',
          genre_name varchar2(20) PATH 'GENRE_NAME',
          duration_film number PATH 'DURATION_FILM',
          year_film date PATH 'YEAR_FILM',
          film_opis varchar2(2000) PATH 'FILM_OPIS');
          commit;
exception            
  when others then
    dbms_output.put_line(sqlerrm);
end;


begin
exportXmlToFIlms();
end;

grant execute on SYSTEM.pack_user to XXXCORE1;
grant select on SYSTEM.sessions to XXXCORE1;

-----фукция рандомной строки (пароль)
create or replace function random_str(v_length number) return varchar2 is
    my_str varchar2(4000);
begin
    for i in 1..v_length loop
        my_str := my_str || dbms_random.string(
            case when dbms_random.value(0, 1) < 0.5 then 'l' else 'x' end, 1);
    end loop;
    return my_str;
end;

select random_str(15) from dual;

---логин
create or replace function RandomString(p_Characters varchar2,
                                        p_length number) return varchar2 is
    l_res varchar2(256);
begin
    select substr(listagg(substr(p_Characters, level, 1)) within group (
            order by dbms_random.value), 1, p_length)
    into l_res
    from dual connect by level <= length(p_Characters);
    return l_res;
end;
select RandomString('qwertyuiopasdfghjklzxcvbnm',14) from dual;

-- заполение 100000 таблицы юсер
declare 
str varchar2(40);
str1 varchar2(40);
msg varchar(40);
begin
FOR Lcntr IN 1..100000
LOOP
str := random_str(15);
str1:=RandomString('qwertyuiopasdfghjklzxcvbnm1234567890',10);
register_user(RandomString('qwertyuiopasdfghjklzxcvbnm1234567890',10),Lcntr,Lcntr,msg);

END LOOP;

end;
select *from users;